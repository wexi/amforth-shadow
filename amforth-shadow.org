# -*- mode: org; mode: auto-fill; fill-column: 75; -*- 
#+TITLE: The Shadow Knows
#+AUTHOR: Enoch
#+EMAIL: ixew@hotmail.com
#+OPTIONS: email:t
#+STARTUP: indent

[[https://github.com/wexi/amforth-shadow][AmForth-Shadow]] <<HQ>> is a sandbox for [[http://en.wikipedia.org/wiki/Atmel_AVR%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20][AVR8]] Forth development that is
maintained by an experienced embedded systems programmer, yet a
novice[fn:1] in Forth. It is hoped that the ideas that are presented here
would be adopted by [[http://amforth.sourceforge.net/][AmForth]] headquarters (HQ). The following summarizes the
Shadow changes to HQ's code.

* Thoughts

[[http://sourceforge.net/users/mtrute][Matthias Trute]], AmForth creator, believes that its GPLv2 license means
that users are entitled to receive the source of any code which the
developer has chosen to include in the distribution, whether this code
has an AmForth origin or not. While [[http://www.amazon.com/Intellectual-Property-Open-Source-Protecting/dp/0596517963][the Shadow questions this claim
based on a reliable source]] the Shadow recommends to abide by Matthias
expectations and solve pesky commercial situations through obfuscation
of the source code. See the new amforth-shell options [[create][--create]],
[[conceal][--conceal]] and [[log][--log]].

* Reduce EEPROM based pointers wear out <<eesy>>

The memory allocation pointers, EE_DP, EE_HERE and EE_EHERE now have
RAM_DP, RAM_HERE and RAM_EHERE copies.  IMPORTANT: Remember to execute
EESY ( -- ) to sync the EE pointer values with their RAM copies.  This
is done automatically for you by tools/amforth-shell.py before leaving
the program.

* Soft Interrupt Service

One of AmForth features is the ability to write Interrupt Service
Routines (ISR), aka Interrupt Handlers, in Forth. However, in the
current implementation (SVN r1430) those ISRs should run with the
hardware interrupt system disabled. This means that one has to keep ISRs
short and defer long processing to the "main". The following changes to
the kernel introduce an eight level soft interrupts queue, allowing the
Forth code Second Level Interrupt Handlers (SLIH) to be interruptible
and thus be as slow to execute as necessary. The new first level
interrupt handling (FLIH) is suitable for type I interrupt sources,
those acknowledged by execution of their interrupt vectors.

CAN interrupts, in the supported at90can32/64/128 \micro{}C's, are
safely routed to the queue by CANGIE.ENIT auto disable. The Forth code
should acknowledge the specific CAN interrupt cause before resetting
ENIT.

** New words

The following ("soft rear-end") words were added to the existing +int
and -int ("hard front-end") which control SREG I-bit

+ int+ ( -- ) "soft interrupts on" :: Enables soft interrupts. If ~int+~
     is the ISR last instruction the ISR routine would return before the
     next queued interrupt is served.

+ int- ( -- ) "soft interrupts off" :: Disables soft interrupts. If this
     instruction is the ISR first the ISR will not be interrupted.

+ int' ( -- addr ) "soft interrupts apostrophe" :: Returns the address
     of a system variable where the lower byte, if non zero, indicates
     occurrence of a hard interrupt overflow. The overflow mark is the
     interrupting-device program address. Clear this mark by: ~0 int'
     c!~. The higher byte, if non-zero, indicates having the soft
     interrupts inhibited.

** Compatibility

As by default soft interrupts are enabled, existing code should not be
impacted. ISRs should be regular Forth colon definitions!

** Limitation

If you are not using USART CTS, see [[handshake]], it is recommended to turn
interrupts off (~int-~) when compiling new code.

** Implementation

1. core/drivers/generic-isr.asm: FLIH with 8 level queue.
2. core/amforth-interpreter.asm: SLIH launcher.
3. core/words/swi??.asm: Soft interrupts control words.

* USART tx/rx isr with RTS/CTS/DTR support <<handshake>>

Define the following macros in your application "template.asm" according
to your project ports/pins use. AmForth is considered a DCE device --
RTS and DTR are input signals, CTS is output. Note that these controls
are independent of each other -- you can implement any of them, none or
all. Also note that RTS requires an edge sensitive interrupt input.

#+BEGIN_EXAMPLE
.set WANT_ISR_RX = 1	;interrupt driven receive
.set WANT_ISR_TX = 1	;interrupt driven transmit

#define RXR_SIZE 32	;= 2⁵ receive queue size
#define TXR_SIZE 64	;= 2⁶ transmit queue size
#+END_EXAMPLE

Overrides the default 16/16 character I/O buffer
	
#+BEGIN_EXAMPLE
#define CTS_ENABLE	;input queue gate
.macro CTS_INIT
  sbi	DDRD, 7		;defaults to CTS_ON
.endmacro
.macro CTS_ON		;invite serial input
  cbi	PORTD, 7
.endmacro
.macro CTS_OFF
  sbi	PORTD, 7
.endmacro
.macro IS_CTS_OFF
  sbis PORTD, 7	;skip if CTS is OFF
.endmacro
#+END_EXAMPLE

The CTS mechanism enables AmForth to control its input characters
rate. CTS turns OFF when the input buffer can accommodate just two more
characters. *IMPORTANT*: The CTS also turns OFF before writing to the
FLASH and to the E²PROM memories as these operations are executed with
the interrupt system disabled. The input buffer has to become half empty
before CTS turns ON again. Change the definitions in
drivers/usart-isr-rx.asm if you need different ON/OFF levels.

#+BEGIN_EXAMPLE
#define RTS_ENABLE	;output queue gate
.macro RTS_INIT
.set pc_ = pc
.org INT6addr
  jmp_ usart_rts_isr
.org pc_
  sbi_ EICRB, ISC61, temp0 ;interrupt on RTS OFF→ON
  sbi	 EIMSK, INT6
.endmacro
.macro IS_RTS_OFF
  sbis PINE, 6	;skip if RTS is OFF
.endmacro
#+END_EXAMPLE

The RTS mechanism enables the host computer to control AmForth output
characaters rate.

#+BEGIN_EXAMPLE
#define DTR_ENABLE
.macro IS_DTR_OFF
  sbic PINE, 7		;skip if DTR is OFF
.endmacro
#+END_EXAMPLE

Output characters are dropped when the host computer is down or not
connected.
 
* WLSCOPE

The shadow is proud to have contributed the Word List Scope idea and
implementation.

* General purpose new words

- allwords ( -- ) :: [ASM] Lists all words in the word-lists search
     order. This command is used by amforth-shell for typing auto
     completion.

- my-words ( WIDn .. WID1 n -- ) :: [ASM] Lists all given
     word-lists. This command is used by amforth-shell to create the
     appl.dic file.

- @c :: [ASM] Like C@ but reads the byte as a signed 8 bit integer
        (i.e., extends sign).

- cinvert :: [ASM] Complements a single byte.

- ?= ( n1 n2 -- n1 false | true ) :: [ASM] twisted compare, true when n1
     equals n2.

- u2/ :: [ASM] Unsigned division by 2.

- u4/ :: [ASM] Unsigned division by 4.

- 4/ :: [ASM] Signed division by 4.

- 4* :: [ASM] Unsigned multiplication by 4.

- -! ( n addr -- ) :: [ASM] Subtracts n from the addressed word.

- -!@ ( n addr -- n' ) :: [ASM] Subtracts n from the addressed word and
     return the difference. 

- +!@ ( n addr -- n') :: [ASM] Adds n to the addressed word and return the
     sum.

- c+! ( b addr -- ) :: [ASM] Adds b to the addressed byte.

- c+!@ ( b addr -- b' ) :: [ASM] Adds b to the addressed byte and return
     the sum.

- -rot  ( n1 n2 n3 -- n3 n1 n2 ) :: [ASM] "not-rote".

- cell- :: [ASM] Cell size address subtraction.

- du256* ( ud -- ud*256 ) :: double unsigned multiplication by 256.  

- du256/ ( ud -- ud/256 ) :: double unsigned division by 256.  

- du<  (ud1 ud2 -- flag ) :: [ASM] is ud1 less than ud2 ?

- d@ d! :: [ASM] double precision fetch and store.

- 2@ 2! :: [ASM] two cell fetch and store.

- rdrop  ( R: X -- ) :: [ASM] Drop one cell from top of run-time stack.

- 2rdrop  ( R: X1 X2 -- ) :: [ASM] Drop two cells from top of run-time
     stack.

- 0drop  ( X -- 0 ) :: [ASM] Replace top of stack with zero.

- reverse  ( X1 .. Xn n -- Xn .. X1 n ) :: LIFO made FIFO.

- weekday  ( d m y -- wd ) :: wd 0/Mon .. 6/Sun

- marker "name" :: A different implementation that backs up word lists
                   only.

* Deviations

+ vocabulary <name> :: [ASM] creates a constant with a new wid (wordlist
     id) value.

+ also <vocabulary-name> :: [ASM] adds the vocabulary's wid to the
     search order head.

* Cookbook

Using Edefer to resolve forward references is wasteful since it adds one
level of runtime indirection and needs additional EEPROM and FLASH space
to implement. Here's a simple solution:

#+BEGIN_EXAMPLE
\ One forward reference capable resolver, use either forward& or &forward.
\ forward resolvers are for local use (placeholder's f-addr from _forward),
\ backward resolvers are for global use (placeholder's f-addr from constant).

variable _forward			\ f-addr to patch

: forward@  _forward @  ;

\ create a placeholder for forward reference xt call
\ use inside compiled word
: forward&
   -1 ,
   dp 1- _forward ! 
;  immediate

\ create a placeholder for forward reference xt constant 
\ use inside compiled word.
: &forward
   postpone (literal) -1 ,
   dp 1- _forward ! 
;  immediate

\ resolve using stacked xt, good for :noname
: :backward  ( xt f-addr -- )
   dup @i -1 <> abort" NOT ERASED"
   !i
;

\ resolve using defined name
: backward:  ( f-addr "name" -- )
   parse-name 2dup find-name  if  ( f-addr addr len xt )
      nip nip swap                ( xt f-addr )
      :backward
   else
      type space abort" NOT FOUND"
   then
;

\ resolve using stacked xt, good for :noname
: :forward  ( xt -- )
   forward@                       ( xt f-addr )
   :backward
;

\ resolve using defined name
: forward:  ( "name" -- )
   forward@                       ( f-addr "name" -- )
   backward:
;

: iexecute  ( test-xt default-xt -- )
   over -1 =  if  nip  else  drop  then
   execute
;

: jexecute  ( test-xt -- )
   dup -1 =  if  drop  else  execute  then
;
#+END_EXAMPLE

* BOOFA bootloader support

BOOFA is an AVRDUDE compatible Flash/EEPROM programmer. [[https://github.com/wexi/boofa][Visit BOOFA
GitHub repository]]. To reserve space for BOOFA put in your template.asm
the following definition:

~.equ AMFORTH_RO_SEG = NRWW_START_ADDR + 512 ;make room for BOOFA~

* amforth-shell.py enhancements

For more information see tools/amforth-shell.py beginning comments.

+ #include vs. #install :: #include would skip uploading if the file has
     already been uploaded in the shell session. #install is
     unconditional. HQ now calls conditional file inclusion #require and
     unconditional inclusion #include. This is influenced by gforth. The
     Shadow (for now) will not follow suit for his deep rooted C
     language habits.

+ --create, -c :: <<create>> The argument of this option is a wordlist
                  whose words need to be captured into the file
                  appl.dic. Multiple -c options can be specifed.

+ --conceal, -C :: <<conceal>> Replace future compiled words that appear
                   in appl.dic with (compact) base 62 numbers with a
                   unique ^^ prefix. Thus, all created names are
                   expected to require just 2 dictionary Flash words.

+ --log :: <<log>> This option collects the actual code that it sent to
           the AmForth system, comments free and following all string
           substituion.

+ --rtscts :: Hardware handshake. This option is for a more reliable
              serial connection if your AmForth implementation supports
              it.

* Emacs support

+ Emacs amforth mode :: amoforth.el is a fork of gforth.el. It enforces
     OpenFirmware indentation rules. It would need much attention to
     reach full usefulness.

* Footnotes

[fn:1] Forth is an old language, no one with less than 20 years of Forth
programming experience counts :-)



